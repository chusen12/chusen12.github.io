{"meta":{"title":"chusen's blog","subtitle":"学如逆水行舟 不进则退","description":"楚森个人博客","author":"楚森","url":"http://www.huxueru.xin"},"pages":[{"title":"关于我","date":"2017-11-06T07:24:26.336Z","updated":"2017-11-06T07:24:26.336Z","comments":false,"path":"about/index.html","permalink":"http://www.huxueru.xin/about/index.html","excerpt":"","text":""},{"title":"","date":"2017-11-05T17:15:49.310Z","updated":"2017-11-05T16:26:58.420Z","comments":false,"path":"categories/index.html","permalink":"http://www.huxueru.xin/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-11-05T17:17:40.802Z","updated":"2017-11-05T17:17:40.802Z","comments":false,"path":"tags/index.html","permalink":"http://www.huxueru.xin/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"大文件的分割与合并","slug":"大文件的分割与合并","date":"2018-03-05T04:31:26.000Z","updated":"2018-03-05T05:01:46.558Z","comments":true,"path":"2018/03/05/大文件的分割与合并/","link":"","permalink":"http://www.huxueru.xin/2018/03/05/大文件的分割与合并/","excerpt":"","text":"1.整体思路&emsp;首先我们会经常遇到一些大的文件的传输问题，对于大的文件传输，整体传输会非常的慢 效率很低，所以我们可以考虑 采用分解的思想，把大文件分解成若干个小文件，然后再对整体进行合并。如果进行跨机器传输的话，我们可以开启若干个线程 每个线程去分解文件，然后通过socket网络传输发送socket服务端 socket服务端也可以采用多个线程去接受 然后合并。 2.整体代码1.文件工具类代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120public class FileUtils &#123; public void mergePartFiles(String dirpath, String partFileSuffix, String mergeFileName) throws Exception &#123; ArrayList&lt;File&gt; partFiles = getDirFiles(dirpath, partFileSuffix);//7 27 Collections.sort(partFiles, new FileComparator()); int partFileSize = (int) partFiles.get(0).length(); RandomAccessFile randomAccessFile = new RandomAccessFile(mergeFileName, \"rw\");// System.out.println(\"文件长度\"+partFileSize * (partFiles.size() - 1) + partFiles.get(partFiles.size() - 1).length()); randomAccessFile.setLength(partFileSize * (partFiles.size() - 1) + partFiles.get(partFiles.size() - 1).length()); randomAccessFile.close(); for (File partFile : partFiles) &#123; System.out.println(partFile.getName() + partFile.length()); &#125; ThreadPoolExecutor threadPool = new ThreadPoolExecutor(partFiles.size(), partFiles.size() * 3, 1, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(partFiles.size() * 2)); for (int i = 0; i &lt; partFiles.size(); i++) &#123; threadPool.execute(new MergeRunnable(i * partFileSize, mergeFileName, partFiles.get(i))); &#125; System.out.println(\"成功了！！！\"); &#125; /** * 获得目录下的文件 * * @param dirpath * @param suffix * @return */ private ArrayList&lt;File&gt; getDirFiles(String dirpath, final String suffix) &#123; File path = new File(dirpath); File[] fileArr = path.listFiles(new FilenameFilter() &#123; @Override public boolean accept(File dir, String name) &#123; String lowerName = name.toLowerCase(); String filesuffix = suffix.toLowerCase(); if (lowerName.endsWith(filesuffix)) &#123; return true; &#125; else return false; &#125; &#125;); ArrayList&lt;File&gt; files = new ArrayList&lt;File&gt;(); for (File file : fileArr) &#123; if (file.isFile()) &#123; files.add(file); &#125; &#125; return files; &#125; public List&lt;String&gt; splitBySize(String fileName, int count) throws Exception &#123; List&lt;String&gt; parts = new ArrayList&lt;String&gt;(); File file = new File(fileName);// int byteSize = (int) Math.ceil(file.length() / (double)count); List&lt;Integer&gt; bytes = new ArrayList&lt;Integer&gt;(); int countLen = (count+\"\").length(); testLen((int) file.length(), count, bytes); ThreadPoolExecutor threadpool = new ThreadPoolExecutor(count, count * 3, 1, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(count * 2)); for (int i = 0; i &lt; count; i++) &#123; String partFileName = file.getName() + \"_\" + leftPad(i+\"\",countLen,'0') + \".part\"; threadpool.execute(new SplitRunnable(bytes.get(i), i * bytes.get(i == 0 ? 0 : i - 1), partFileName, file)); parts.add(partFileName); &#125; return parts; &#125; private String leftPad(String str, int countLen, char c) &#123; if (str.length() &gt; countLen) &#123; return str; &#125; char[] chs = new char[countLen]; Arrays.fill(chs, c); char[] src = str.toCharArray(); System.arraycopy(src, 0, chs, countLen - src.length, src.length); return new String(chs); &#125; public static void main(String[] args) throws Exception &#123; new FileUtils().mergePartFiles(\"D:\\\\test\\\\frj\\\\\", \".mp4\", \"D:\\\\test\\\\frj\\\\merge.mp4\"); //1,626,409,091 &#125; /*** * 构建文件大小集合 * * @param len * @param count * @param arr */ public static void testLen(Integer len, int count, List&lt;Integer&gt; arr) &#123; int i = len / count; int j = 0; if (len % count == 0) &#123; while (j &lt; count) &#123; arr.add(i); j++; &#125; &#125; else &#123; int sum = 0; while (j &lt; count - 1) &#123; sum += i; arr.add(i); j++; &#125; arr.add(len - sum); &#125; System.out.println(arr); &#125; /** * 根据文件名称 比较文件 */ private class FileComparator implements Comparator&lt;File&gt; &#123; @Override public int compare(File o1, File o2) &#123; return o1.getName().compareToIgnoreCase(o2.getName()); &#125; &#125;&#125; 2.文件分解线程主要代码123456789101112131415161718192021222324252627282930313233343536373839404142public class SplitRunnable implements Runnable &#123; int byteSize; String partFileName; File originFile; int startPos; Socket socket; public SplitRunnable(int byteSize, int startPos,String partFileName,File originFile) throws IOException &#123; this.startPos = startPos; this.byteSize = byteSize; this.partFileName = partFileName; this.originFile = originFile;// socket = new Socket(\"localhost\",8088); &#125; @Override public void run() &#123; RandomAccessFile rfile; OutputStream os;// DataOutputStream dos; try &#123;// dos = new DataOutputStream(socket.getOutputStream()); rfile = new RandomAccessFile(originFile,\"r\"); byte[] b = new byte[byteSize]; rfile.seek(startPos); int s = rfile.read(b); File file = new File(partFileName);// 写到本地的时候用 os = new FileOutputStream(\"d:/test/frj/\" + partFileName);// dos.writeUTF(file.getName());// dos.flush();// dos.writeLong(file.length());// dos.flush();// dos.write(b,0,s);// dos.flush();// dos.close(); os.write(b,0,s); os.flush(); os.close(); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 3.文件合并线程主要代码123456789101112131415161718192021222324252627public class MergeRunnable implements Runnable &#123; long startPos; String mergeFileName; File partFile; public MergeRunnable(int startPos, String mergeFileName, File partFile) &#123; this.startPos = startPos; this.mergeFileName = mergeFileName; this.partFile = partFile; &#125; @Override public void run() &#123; RandomAccessFile rfile; try &#123; rfile = new RandomAccessFile(mergeFileName,\"rw\"); rfile.seek(startPos); FileInputStream fs = new FileInputStream(partFile); byte[] b = new byte[fs.available()]; fs.read(b); fs.close(); rfile.write(b); rfile.close(); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://www.huxueru.xin/tags/java/"}]},{"title":"虚拟机使用NAT模式配置静态ip","slug":"虚拟机使用NAT模式配置静态ip","date":"2017-12-05T01:09:01.000Z","updated":"2017-12-05T05:03:03.823Z","comments":true,"path":"2017/12/05/虚拟机使用NAT模式配置静态ip/","link":"","permalink":"http://www.huxueru.xin/2017/12/05/虚拟机使用NAT模式配置静态ip/","excerpt":"","text":"##1 基本配置 ##`之所以使用NAT模式而不使用桥接模式 是因为桥接模式非常依赖网络环境 ip容易改变 这是非常不好的 话不多说 直接贴图吧！ List item","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.huxueru.xin/tags/linux/"}]},{"title":"前言","slug":"前言","date":"2017-11-06T07:48:36.000Z","updated":"2017-11-08T13:04:19.606Z","comments":true,"path":"2017/11/06/前言/","link":"","permalink":"http://www.huxueru.xin/2017/11/06/前言/","excerpt":"","text":"博客搭建 hello,欢迎来到我的博客，首先关于具体的搭建过程我就不详细介绍了，网上有很多的教程，这里就不去重复写了，关于这个博客，断断续续的搭了两三天，之前我一直是在word文档上记录平时的错误，但是呢这有一定的局限性，一是不能达到分享的目的，二是word文档没有一个好的归档排版，因此搭建博客，同时非常感谢网上的热心人士开源与交流，关于我的博客，我想记录一些平时学习和以后工作遇到的问题，旨在给和我遇到一样问题的同学一些思路，同时我本人也不是一个大牛，然后我们可以一起学习和交流，欢迎各位给我留言。 联系我 如果各位发现文章有错误和更好的建议 欢迎联系我。 微信:fivemu-cs 邮箱:chusen12@163.com QQ:2676840121","categories":[],"tags":[{"name":"杂记","slug":"杂记","permalink":"http://www.huxueru.xin/tags/杂记/"}]}]}